"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Actor`."""
  allActors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Actor`."""
    orderBy: [ActorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActorCondition
  ): ActorsConnection

  """Reads and enables pagination through a set of `ActorInfo`."""
  allActorInfos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActorInfo`."""
    orderBy: [ActorInfosOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActorInfoCondition
  ): ActorInfosConnection

  """Reads and enables pagination through a set of `Address`."""
  allAddresses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition
  ): AddressesConnection

  """Reads and enables pagination through a set of `Category`."""
  allCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition
  ): CategoriesConnection

  """Reads and enables pagination through a set of `City`."""
  allCities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition
  ): CitiesConnection

  """Reads and enables pagination through a set of `Country`."""
  allCountries(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition
  ): CountriesConnection

  """Reads and enables pagination through a set of `Customer`."""
  allCustomers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerCondition
  ): CustomersConnection

  """Reads and enables pagination through a set of `CustomerList`."""
  allCustomerLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CustomerList`."""
    orderBy: [CustomerListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerListCondition
  ): CustomerListsConnection

  """Reads and enables pagination through a set of `Film`."""
  allFilms(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Film`."""
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCondition
  ): FilmsConnection

  """Reads and enables pagination through a set of `FilmActor`."""
  allFilmActors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmActor`."""
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition
  ): FilmActorsConnection

  """Reads and enables pagination through a set of `FilmCategory`."""
  allFilmCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmCategory`."""
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition
  ): FilmCategoriesConnection

  """Reads and enables pagination through a set of `FilmList`."""
  allFilmLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmList`."""
    orderBy: [FilmListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmListCondition
  ): FilmListsConnection

  """Reads and enables pagination through a set of `Inventory`."""
  allInventories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Inventory`."""
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InventoryCondition
  ): InventoriesConnection

  """Reads and enables pagination through a set of `Language`."""
  allLanguages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCondition
  ): LanguagesConnection

  """
  Reads and enables pagination through a set of `NicerButSlowerFilmList`.
  """
  allNicerButSlowerFilmLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NicerButSlowerFilmList`."""
    orderBy: [NicerButSlowerFilmListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NicerButSlowerFilmListCondition
  ): NicerButSlowerFilmListsConnection

  """Reads and enables pagination through a set of `Payment`."""
  allPayments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition
  ): PaymentsConnection

  """Reads and enables pagination through a set of `Rental`."""
  allRentals(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Rental`."""
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition
  ): RentalsConnection

  """Reads and enables pagination through a set of `SalesByFilmCategory`."""
  allSalesByFilmCategories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SalesByFilmCategory`."""
    orderBy: [SalesByFilmCategoriesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SalesByFilmCategoryCondition
  ): SalesByFilmCategoriesConnection

  """Reads and enables pagination through a set of `SalesByStore`."""
  allSalesByStores(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SalesByStore`."""
    orderBy: [SalesByStoresOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SalesByStoreCondition
  ): SalesByStoresConnection

  """Reads and enables pagination through a set of `Staff`."""
  allStaff(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Staff`."""
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffCondition
  ): StaffConnection

  """Reads and enables pagination through a set of `StaffList`."""
  allStaffLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StaffList`."""
    orderBy: [StaffListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffListCondition
  ): StaffListsConnection

  """Reads and enables pagination through a set of `Store`."""
  allStores(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Store`."""
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition
  ): StoresConnection

  """Reads and enables pagination through a set of `TodoItem`."""
  allTodoItems(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TodoItem`."""
    orderBy: [TodoItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TodoItemCondition
  ): TodoItemsConnection

  """Reads and enables pagination through a set of `TodoList`."""
  allTodoLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TodoListCondition
  ): TodoListsConnection
  actorByActorId(actorId: Int!): Actor
  addressByAddressId(addressId: Int!): Address
  categoryByCategoryId(categoryId: Int!): Category
  cityByCityId(cityId: Int!): City
  countryByCountryId(countryId: Int!): Country
  customerByCustomerId(customerId: Int!): Customer
  filmByFilmId(filmId: Int!): Film
  filmActorByActorIdAndFilmId(actorId: Int!, filmId: Int!): FilmActor
  filmCategoryByFilmIdAndCategoryId(filmId: Int!, categoryId: Int!): FilmCategory
  inventoryByInventoryId(inventoryId: Int!): Inventory
  languageByLanguageId(languageId: Int!): Language
  paymentByPaymentId(paymentId: Int!): Payment
  rentalByRentalId(rentalId: Int!): Rental
  staffByStaffId(staffId: Int!): Staff
  storeByStoreId(storeId: Int!): Store
  todoItemById(id: Int!): TodoItem
  todoListById(id: Int!): TodoList
  _groupConcat(arg0: String, arg1: String): String
  lastDay(arg0: Datetime!): Date
  viewerId: Int

  """Reads a single `Actor` using its globally unique `ID`."""
  actor(
    """The globally unique `ID` to be used in selecting a single `Actor`."""
    nodeId: ID!
  ): Actor

  """Reads a single `Address` using its globally unique `ID`."""
  address(
    """The globally unique `ID` to be used in selecting a single `Address`."""
    nodeId: ID!
  ): Address

  """Reads a single `Category` using its globally unique `ID`."""
  category(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category

  """Reads a single `City` using its globally unique `ID`."""
  city(
    """The globally unique `ID` to be used in selecting a single `City`."""
    nodeId: ID!
  ): City

  """Reads a single `Country` using its globally unique `ID`."""
  country(
    """The globally unique `ID` to be used in selecting a single `Country`."""
    nodeId: ID!
  ): Country

  """Reads a single `Customer` using its globally unique `ID`."""
  customer(
    """The globally unique `ID` to be used in selecting a single `Customer`."""
    nodeId: ID!
  ): Customer

  """Reads a single `Film` using its globally unique `ID`."""
  film(
    """The globally unique `ID` to be used in selecting a single `Film`."""
    nodeId: ID!
  ): Film

  """Reads a single `FilmActor` using its globally unique `ID`."""
  filmActor(
    """The globally unique `ID` to be used in selecting a single `FilmActor`."""
    nodeId: ID!
  ): FilmActor

  """Reads a single `FilmCategory` using its globally unique `ID`."""
  filmCategory(
    """
    The globally unique `ID` to be used in selecting a single `FilmCategory`.
    """
    nodeId: ID!
  ): FilmCategory

  """Reads a single `Inventory` using its globally unique `ID`."""
  inventory(
    """The globally unique `ID` to be used in selecting a single `Inventory`."""
    nodeId: ID!
  ): Inventory

  """Reads a single `Language` using its globally unique `ID`."""
  language(
    """The globally unique `ID` to be used in selecting a single `Language`."""
    nodeId: ID!
  ): Language

  """Reads a single `Payment` using its globally unique `ID`."""
  payment(
    """The globally unique `ID` to be used in selecting a single `Payment`."""
    nodeId: ID!
  ): Payment

  """Reads a single `Rental` using its globally unique `ID`."""
  rental(
    """The globally unique `ID` to be used in selecting a single `Rental`."""
    nodeId: ID!
  ): Rental

  """Reads a single `Staff` using its globally unique `ID`."""
  staff(
    """The globally unique `ID` to be used in selecting a single `Staff`."""
    nodeId: ID!
  ): Staff

  """Reads a single `Store` using its globally unique `ID`."""
  store(
    """The globally unique `ID` to be used in selecting a single `Store`."""
    nodeId: ID!
  ): Store

  """Reads a single `TodoItem` using its globally unique `ID`."""
  todoItem(
    """The globally unique `ID` to be used in selecting a single `TodoItem`."""
    nodeId: ID!
  ): TodoItem

  """Reads a single `TodoList` using its globally unique `ID`."""
  todoList(
    """The globally unique `ID` to be used in selecting a single `TodoList`."""
    nodeId: ID!
  ): TodoList
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Actor` values."""
type ActorsConnection {
  """A list of `Actor` objects."""
  nodes: [Actor]!

  """
  A list of edges which contains the `Actor` and cursor to aid in pagination.
  """
  edges: [ActorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Actor` you could get from the connection."""
  totalCount: Int!
}

type Actor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  actorId: Int!
  firstName: String!
  lastName: String!
  lastUpdate: Datetime!

  """Reads and enables pagination through a set of `FilmActor`."""
  filmActorsByActorId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmActor`."""
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition
  ): FilmActorsConnection!
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A connection to a list of `FilmActor` values."""
type FilmActorsConnection {
  """A list of `FilmActor` objects."""
  nodes: [FilmActor]!

  """
  A list of edges which contains the `FilmActor` and cursor to aid in pagination.
  """
  edges: [FilmActorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `FilmActor` you could get from the connection."""
  totalCount: Int!
}

type FilmActor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  actorId: Int!
  filmId: Int!
  lastUpdate: Datetime!

  """Reads a single `Actor` that is related to this `FilmActor`."""
  actorByActorId: Actor

  """Reads a single `Film` that is related to this `FilmActor`."""
  filmByFilmId: Film
}

type Film implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  filmId: Int!
  title: String!
  description: String
  releaseYear: Year
  languageId: Int!
  rentalDuration: Int!
  rentalRate: BigFloat!
  length: Int
  replacementCost: BigFloat!
  rating: MpaaRating
  lastUpdate: Datetime!
  specialFeatures: [String]
  fulltext: String!

  """Reads a single `Language` that is related to this `Film`."""
  languageByLanguageId: Language

  """Reads and enables pagination through a set of `FilmActor`."""
  filmActorsByFilmId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmActor`."""
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition
  ): FilmActorsConnection!

  """Reads and enables pagination through a set of `FilmCategory`."""
  filmCategoriesByFilmId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmCategory`."""
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition
  ): FilmCategoriesConnection!

  """Reads and enables pagination through a set of `Inventory`."""
  inventoriesByFilmId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Inventory`."""
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InventoryCondition
  ): InventoriesConnection!
}

scalar Year

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

enum MpaaRating {
  G
  PG
  PG_13
  R
  NC_17
}

type Language implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  languageId: Int!
  name: String!
  lastUpdate: Datetime!

  """Reads and enables pagination through a set of `Film`."""
  filmsByLanguageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Film`."""
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCondition
  ): FilmsConnection!
}

"""A connection to a list of `Film` values."""
type FilmsConnection {
  """A list of `Film` objects."""
  nodes: [Film]!

  """
  A list of edges which contains the `Film` and cursor to aid in pagination.
  """
  edges: [FilmsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Film` you could get from the connection."""
  totalCount: Int!
}

"""A `Film` edge in the connection."""
type FilmsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Film` at the end of the edge."""
  node: Film
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Film`."""
enum FilmsOrderBy {
  NATURAL
  FILM_ID_ASC
  FILM_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  RELEASE_YEAR_ASC
  RELEASE_YEAR_DESC
  LANGUAGE_ID_ASC
  LANGUAGE_ID_DESC
  RENTAL_DURATION_ASC
  RENTAL_DURATION_DESC
  RENTAL_RATE_ASC
  RENTAL_RATE_DESC
  LENGTH_ASC
  LENGTH_DESC
  REPLACEMENT_COST_ASC
  REPLACEMENT_COST_DESC
  RATING_ASC
  RATING_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  SPECIAL_FEATURES_ASC
  SPECIAL_FEATURES_DESC
  FULLTEXT_ASC
  FULLTEXT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Film` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input FilmCondition {
  """Checks for equality with the object’s `filmId` field."""
  filmId: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `releaseYear` field."""
  releaseYear: Year

  """Checks for equality with the object’s `languageId` field."""
  languageId: Int

  """Checks for equality with the object’s `rentalDuration` field."""
  rentalDuration: Int

  """Checks for equality with the object’s `rentalRate` field."""
  rentalRate: BigFloat

  """Checks for equality with the object’s `length` field."""
  length: Int

  """Checks for equality with the object’s `replacementCost` field."""
  replacementCost: BigFloat

  """Checks for equality with the object’s `rating` field."""
  rating: MpaaRating

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime

  """Checks for equality with the object’s `specialFeatures` field."""
  specialFeatures: [String]

  """Checks for equality with the object’s `fulltext` field."""
  fulltext: String
}

"""Methods to use when ordering `FilmActor`."""
enum FilmActorsOrderBy {
  NATURAL
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FILM_ID_ASC
  FILM_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `FilmActor` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FilmActorCondition {
  """Checks for equality with the object’s `actorId` field."""
  actorId: Int

  """Checks for equality with the object’s `filmId` field."""
  filmId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `FilmCategory` values."""
type FilmCategoriesConnection {
  """A list of `FilmCategory` objects."""
  nodes: [FilmCategory]!

  """
  A list of edges which contains the `FilmCategory` and cursor to aid in pagination.
  """
  edges: [FilmCategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `FilmCategory` you could get from the connection."""
  totalCount: Int!
}

type FilmCategory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  filmId: Int!
  categoryId: Int!
  lastUpdate: Datetime!

  """Reads a single `Film` that is related to this `FilmCategory`."""
  filmByFilmId: Film

  """Reads a single `Category` that is related to this `FilmCategory`."""
  categoryByCategoryId: Category
}

type Category implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  categoryId: Int!
  name: String!
  lastUpdate: Datetime!

  """Reads and enables pagination through a set of `FilmCategory`."""
  filmCategoriesByCategoryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FilmCategory`."""
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition
  ): FilmCategoriesConnection!
}

"""Methods to use when ordering `FilmCategory`."""
enum FilmCategoriesOrderBy {
  NATURAL
  FILM_ID_ASC
  FILM_ID_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `FilmCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input FilmCategoryCondition {
  """Checks for equality with the object’s `filmId` field."""
  filmId: Int

  """Checks for equality with the object’s `categoryId` field."""
  categoryId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A `FilmCategory` edge in the connection."""
type FilmCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `FilmCategory` at the end of the edge."""
  node: FilmCategory
}

"""A connection to a list of `Inventory` values."""
type InventoriesConnection {
  """A list of `Inventory` objects."""
  nodes: [Inventory]!

  """
  A list of edges which contains the `Inventory` and cursor to aid in pagination.
  """
  edges: [InventoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Inventory` you could get from the connection."""
  totalCount: Int!
}

type Inventory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  inventoryId: Int!
  filmId: Int!
  storeId: Int!
  lastUpdate: Datetime!

  """Reads a single `Film` that is related to this `Inventory`."""
  filmByFilmId: Film

  """Reads and enables pagination through a set of `Rental`."""
  rentalsByInventoryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Rental`."""
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition
  ): RentalsConnection!
}

"""A connection to a list of `Rental` values."""
type RentalsConnection {
  """A list of `Rental` objects."""
  nodes: [Rental]!

  """
  A list of edges which contains the `Rental` and cursor to aid in pagination.
  """
  edges: [RentalsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Rental` you could get from the connection."""
  totalCount: Int!
}

type Rental implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  rentalId: Int!
  rentalDate: Datetime!
  inventoryId: Int!
  customerId: Int!
  returnDate: Datetime
  staffId: Int!
  lastUpdate: Datetime!

  """Reads a single `Inventory` that is related to this `Rental`."""
  inventoryByInventoryId: Inventory

  """Reads a single `Customer` that is related to this `Rental`."""
  customerByCustomerId: Customer

  """Reads a single `Staff` that is related to this `Rental`."""
  staffByStaffId: Staff

  """Reads and enables pagination through a set of `Payment`."""
  paymentsByRentalId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition
  ): PaymentsConnection!
}

type Customer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  customerId: Int!
  storeId: Int!
  firstName: String!
  lastName: String!
  email: String
  addressId: Int!
  activebool: Boolean!
  createDate: Date!
  lastUpdate: Datetime
  active: Int

  """Reads a single `Address` that is related to this `Customer`."""
  addressByAddressId: Address

  """Reads and enables pagination through a set of `Payment`."""
  paymentsByCustomerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition
  ): PaymentsConnection!

  """Reads and enables pagination through a set of `Rental`."""
  rentalsByCustomerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Rental`."""
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition
  ): RentalsConnection!
}

"""The day, does not include a time."""
scalar Date

type Address implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  addressId: Int!
  address: String!
  address2: String
  district: String!
  cityId: Int!
  postalCode: String
  phone: String!
  lastUpdate: Datetime!

  """Reads a single `City` that is related to this `Address`."""
  cityByCityId: City

  """Reads and enables pagination through a set of `Customer`."""
  customersByAddressId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerCondition
  ): CustomersConnection!

  """Reads and enables pagination through a set of `Staff`."""
  staffByAddressId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Staff`."""
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffCondition
  ): StaffConnection!

  """Reads and enables pagination through a set of `Store`."""
  storesByAddressId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Store`."""
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition
  ): StoresConnection!
}

type City implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  cityId: Int!
  city: String!
  countryId: Int!
  lastUpdate: Datetime!

  """Reads a single `Country` that is related to this `City`."""
  countryByCountryId: Country

  """Reads and enables pagination through a set of `Address`."""
  addressesByCityId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Address`."""
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition
  ): AddressesConnection!
}

type Country implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  countryId: Int!
  country: String!
  lastUpdate: Datetime!

  """Reads and enables pagination through a set of `City`."""
  citiesByCountryId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition
  ): CitiesConnection!
}

"""A connection to a list of `City` values."""
type CitiesConnection {
  """A list of `City` objects."""
  nodes: [City]!

  """
  A list of edges which contains the `City` and cursor to aid in pagination.
  """
  edges: [CitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `City` you could get from the connection."""
  totalCount: Int!
}

"""A `City` edge in the connection."""
type CitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `City` at the end of the edge."""
  node: City
}

"""Methods to use when ordering `City`."""
enum CitiesOrderBy {
  NATURAL
  CITY_ID_ASC
  CITY_ID_DESC
  CITY_ASC
  CITY_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `City` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CityCondition {
  """Checks for equality with the object’s `cityId` field."""
  cityId: Int

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `countryId` field."""
  countryId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `Address` values."""
type AddressesConnection {
  """A list of `Address` objects."""
  nodes: [Address]!

  """
  A list of edges which contains the `Address` and cursor to aid in pagination.
  """
  edges: [AddressesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Address` you could get from the connection."""
  totalCount: Int!
}

"""A `Address` edge in the connection."""
type AddressesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Address` at the end of the edge."""
  node: Address
}

"""Methods to use when ordering `Address`."""
enum AddressesOrderBy {
  NATURAL
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS2_ASC
  ADDRESS2_DESC
  DISTRICT_ASC
  DISTRICT_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  POSTAL_CODE_ASC
  POSTAL_CODE_DESC
  PHONE_ASC
  PHONE_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Address` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AddressCondition {
  """Checks for equality with the object’s `addressId` field."""
  addressId: Int

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `address2` field."""
  address2: String

  """Checks for equality with the object’s `district` field."""
  district: String

  """Checks for equality with the object’s `cityId` field."""
  cityId: Int

  """Checks for equality with the object’s `postalCode` field."""
  postalCode: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `Customer` values."""
type CustomersConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!

  """
  A list of edges which contains the `Customer` and cursor to aid in pagination.
  """
  edges: [CustomersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection."""
type CustomersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Customer` at the end of the edge."""
  node: Customer
}

"""Methods to use when ordering `Customer`."""
enum CustomersOrderBy {
  NATURAL
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  STORE_ID_ASC
  STORE_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  ACTIVEBOOL_ASC
  ACTIVEBOOL_DESC
  CREATE_DATE_ASC
  CREATE_DATE_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Customer` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CustomerCondition {
  """Checks for equality with the object’s `customerId` field."""
  customerId: Int

  """Checks for equality with the object’s `storeId` field."""
  storeId: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `addressId` field."""
  addressId: Int

  """Checks for equality with the object’s `activebool` field."""
  activebool: Boolean

  """Checks for equality with the object’s `createDate` field."""
  createDate: Date

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime

  """Checks for equality with the object’s `active` field."""
  active: Int
}

"""A connection to a list of `Staff` values."""
type StaffConnection {
  """A list of `Staff` objects."""
  nodes: [Staff]!

  """
  A list of edges which contains the `Staff` and cursor to aid in pagination.
  """
  edges: [StaffEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Staff` you could get from the connection."""
  totalCount: Int!
}

type Staff implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  staffId: Int!
  firstName: String!
  lastName: String!
  addressId: Int!
  email: String
  storeId: Int!
  active: Boolean!
  username: String!
  password: String
  lastUpdate: Datetime!
  picture: String

  """Reads a single `Address` that is related to this `Staff`."""
  addressByAddressId: Address

  """Reads and enables pagination through a set of `Payment`."""
  paymentsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition
  ): PaymentsConnection!

  """Reads and enables pagination through a set of `Rental`."""
  rentalsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Rental`."""
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition
  ): RentalsConnection!

  """Reads and enables pagination through a set of `Store`."""
  storesByManagerStaffId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Store`."""
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition
  ): StoresConnection!
}

"""A connection to a list of `Payment` values."""
type PaymentsConnection {
  """A list of `Payment` objects."""
  nodes: [Payment]!

  """
  A list of edges which contains the `Payment` and cursor to aid in pagination.
  """
  edges: [PaymentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Payment` you could get from the connection."""
  totalCount: Int!
}

type Payment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  paymentId: Int!
  customerId: Int!
  staffId: Int!
  rentalId: Int!
  amount: BigFloat!
  paymentDate: Datetime!

  """Reads a single `Customer` that is related to this `Payment`."""
  customerByCustomerId: Customer

  """Reads a single `Staff` that is related to this `Payment`."""
  staffByStaffId: Staff

  """Reads a single `Rental` that is related to this `Payment`."""
  rentalByRentalId: Rental
}

"""A `Payment` edge in the connection."""
type PaymentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Payment` at the end of the edge."""
  node: Payment
}

"""Methods to use when ordering `Payment`."""
enum PaymentsOrderBy {
  NATURAL
  PAYMENT_ID_ASC
  PAYMENT_ID_DESC
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  RENTAL_ID_ASC
  RENTAL_ID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  PAYMENT_DATE_ASC
  PAYMENT_DATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PaymentCondition {
  """Checks for equality with the object’s `paymentId` field."""
  paymentId: Int

  """Checks for equality with the object’s `customerId` field."""
  customerId: Int

  """Checks for equality with the object’s `staffId` field."""
  staffId: Int

  """Checks for equality with the object’s `rentalId` field."""
  rentalId: Int

  """Checks for equality with the object’s `amount` field."""
  amount: BigFloat

  """Checks for equality with the object’s `paymentDate` field."""
  paymentDate: Datetime
}

"""Methods to use when ordering `Rental`."""
enum RentalsOrderBy {
  NATURAL
  RENTAL_ID_ASC
  RENTAL_ID_DESC
  RENTAL_DATE_ASC
  RENTAL_DATE_DESC
  INVENTORY_ID_ASC
  INVENTORY_ID_DESC
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  RETURN_DATE_ASC
  RETURN_DATE_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Rental` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RentalCondition {
  """Checks for equality with the object’s `rentalId` field."""
  rentalId: Int

  """Checks for equality with the object’s `rentalDate` field."""
  rentalDate: Datetime

  """Checks for equality with the object’s `inventoryId` field."""
  inventoryId: Int

  """Checks for equality with the object’s `customerId` field."""
  customerId: Int

  """Checks for equality with the object’s `returnDate` field."""
  returnDate: Datetime

  """Checks for equality with the object’s `staffId` field."""
  staffId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `Store` values."""
type StoresConnection {
  """A list of `Store` objects."""
  nodes: [Store]!

  """
  A list of edges which contains the `Store` and cursor to aid in pagination.
  """
  edges: [StoresEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Store` you could get from the connection."""
  totalCount: Int!
}

type Store implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  storeId: Int!
  managerStaffId: Int!
  addressId: Int!
  lastUpdate: Datetime!

  """Reads a single `Staff` that is related to this `Store`."""
  staffByManagerStaffId: Staff

  """Reads a single `Address` that is related to this `Store`."""
  addressByAddressId: Address
}

"""A `Store` edge in the connection."""
type StoresEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Store` at the end of the edge."""
  node: Store
}

"""Methods to use when ordering `Store`."""
enum StoresOrderBy {
  NATURAL
  STORE_ID_ASC
  STORE_ID_DESC
  MANAGER_STAFF_ID_ASC
  MANAGER_STAFF_ID_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Store` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StoreCondition {
  """Checks for equality with the object’s `storeId` field."""
  storeId: Int

  """Checks for equality with the object’s `managerStaffId` field."""
  managerStaffId: Int

  """Checks for equality with the object’s `addressId` field."""
  addressId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A `Staff` edge in the connection."""
type StaffEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Staff` at the end of the edge."""
  node: Staff
}

"""Methods to use when ordering `Staff`."""
enum StaffOrderBy {
  NATURAL
  STAFF_ID_ASC
  STAFF_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  STORE_ID_ASC
  STORE_ID_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  USERNAME_ASC
  USERNAME_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PICTURE_ASC
  PICTURE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Staff` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StaffCondition {
  """Checks for equality with the object’s `staffId` field."""
  staffId: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `addressId` field."""
  addressId: Int

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `storeId` field."""
  storeId: Int

  """Checks for equality with the object’s `active` field."""
  active: Boolean

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime

  """Checks for equality with the object’s `picture` field."""
  picture: String
}

"""A `Rental` edge in the connection."""
type RentalsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Rental` at the end of the edge."""
  node: Rental
}

"""A `Inventory` edge in the connection."""
type InventoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Inventory` at the end of the edge."""
  node: Inventory
}

"""Methods to use when ordering `Inventory`."""
enum InventoriesOrderBy {
  NATURAL
  INVENTORY_ID_ASC
  INVENTORY_ID_DESC
  FILM_ID_ASC
  FILM_ID_DESC
  STORE_ID_ASC
  STORE_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Inventory` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input InventoryCondition {
  """Checks for equality with the object’s `inventoryId` field."""
  inventoryId: Int

  """Checks for equality with the object’s `filmId` field."""
  filmId: Int

  """Checks for equality with the object’s `storeId` field."""
  storeId: Int

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A `FilmActor` edge in the connection."""
type FilmActorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `FilmActor` at the end of the edge."""
  node: FilmActor
}

"""A `Actor` edge in the connection."""
type ActorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Actor` at the end of the edge."""
  node: Actor
}

"""Methods to use when ordering `Actor`."""
enum ActorsOrderBy {
  NATURAL
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Actor` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ActorCondition {
  """Checks for equality with the object’s `actorId` field."""
  actorId: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `ActorInfo` values."""
type ActorInfosConnection {
  """A list of `ActorInfo` objects."""
  nodes: [ActorInfo]!

  """
  A list of edges which contains the `ActorInfo` and cursor to aid in pagination.
  """
  edges: [ActorInfosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ActorInfo` you could get from the connection."""
  totalCount: Int!
}

type ActorInfo {
  actorId: Int
  firstName: String
  lastName: String
  filmInfo: String
}

"""A `ActorInfo` edge in the connection."""
type ActorInfosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ActorInfo` at the end of the edge."""
  node: ActorInfo
}

"""Methods to use when ordering `ActorInfo`."""
enum ActorInfosOrderBy {
  NATURAL
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  FILM_INFO_ASC
  FILM_INFO_DESC
}

"""
A condition to be used against `ActorInfo` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ActorInfoCondition {
  """Checks for equality with the object’s `actorId` field."""
  actorId: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `filmInfo` field."""
  filmInfo: String
}

"""A connection to a list of `Category` values."""
type CategoriesConnection {
  """A list of `Category` objects."""
  nodes: [Category]!

  """
  A list of edges which contains the `Category` and cursor to aid in pagination.
  """
  edges: [CategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Category` at the end of the edge."""
  node: Category
}

"""Methods to use when ordering `Category`."""
enum CategoriesOrderBy {
  NATURAL
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CategoryCondition {
  """Checks for equality with the object’s `categoryId` field."""
  categoryId: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `Country` values."""
type CountriesConnection {
  """A list of `Country` objects."""
  nodes: [Country]!

  """
  A list of edges which contains the `Country` and cursor to aid in pagination.
  """
  edges: [CountriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection."""
type CountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Country` at the end of the edge."""
  node: Country
}

"""Methods to use when ordering `Country`."""
enum CountriesOrderBy {
  NATURAL
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CountryCondition {
  """Checks for equality with the object’s `countryId` field."""
  countryId: Int

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `CustomerList` values."""
type CustomerListsConnection {
  """A list of `CustomerList` objects."""
  nodes: [CustomerList]!

  """
  A list of edges which contains the `CustomerList` and cursor to aid in pagination.
  """
  edges: [CustomerListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CustomerList` you could get from the connection."""
  totalCount: Int!
}

type CustomerList {
  id: Int
  name: String
  address: String
  zipCode: String
  phone: String
  city: String
  country: String
  notes: String
  sid: Int
}

"""A `CustomerList` edge in the connection."""
type CustomerListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CustomerList` at the end of the edge."""
  node: CustomerList
}

"""Methods to use when ordering `CustomerList`."""
enum CustomerListsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ZIP_CODE_ASC
  ZIP_CODE_DESC
  PHONE_ASC
  PHONE_DESC
  CITY_ASC
  CITY_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  NOTES_ASC
  NOTES_DESC
  SID_ASC
  SID_DESC
}

"""
A condition to be used against `CustomerList` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CustomerListCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `zipCode` field."""
  zipCode: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `sid` field."""
  sid: Int
}

"""A connection to a list of `FilmList` values."""
type FilmListsConnection {
  """A list of `FilmList` objects."""
  nodes: [FilmList]!

  """
  A list of edges which contains the `FilmList` and cursor to aid in pagination.
  """
  edges: [FilmListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `FilmList` you could get from the connection."""
  totalCount: Int!
}

type FilmList {
  fid: Int
  title: String
  description: String
  category: String
  price: BigFloat
  length: Int
  rating: MpaaRating
  actors: String
}

"""A `FilmList` edge in the connection."""
type FilmListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `FilmList` at the end of the edge."""
  node: FilmList
}

"""Methods to use when ordering `FilmList`."""
enum FilmListsOrderBy {
  NATURAL
  FID_ASC
  FID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PRICE_ASC
  PRICE_DESC
  LENGTH_ASC
  LENGTH_DESC
  RATING_ASC
  RATING_DESC
  ACTORS_ASC
  ACTORS_DESC
}

"""
A condition to be used against `FilmList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FilmListCondition {
  """Checks for equality with the object’s `fid` field."""
  fid: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `price` field."""
  price: BigFloat

  """Checks for equality with the object’s `length` field."""
  length: Int

  """Checks for equality with the object’s `rating` field."""
  rating: MpaaRating

  """Checks for equality with the object’s `actors` field."""
  actors: String
}

"""A connection to a list of `Language` values."""
type LanguagesConnection {
  """A list of `Language` objects."""
  nodes: [Language]!

  """
  A list of edges which contains the `Language` and cursor to aid in pagination.
  """
  edges: [LanguagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Language` you could get from the connection."""
  totalCount: Int!
}

"""A `Language` edge in the connection."""
type LanguagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Language` at the end of the edge."""
  node: Language
}

"""Methods to use when ordering `Language`."""
enum LanguagesOrderBy {
  NATURAL
  LANGUAGE_ID_ASC
  LANGUAGE_ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Language` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LanguageCondition {
  """Checks for equality with the object’s `languageId` field."""
  languageId: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `lastUpdate` field."""
  lastUpdate: Datetime
}

"""A connection to a list of `NicerButSlowerFilmList` values."""
type NicerButSlowerFilmListsConnection {
  """A list of `NicerButSlowerFilmList` objects."""
  nodes: [NicerButSlowerFilmList]!

  """
  A list of edges which contains the `NicerButSlowerFilmList` and cursor to aid in pagination.
  """
  edges: [NicerButSlowerFilmListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `NicerButSlowerFilmList` you could get from the connection.
  """
  totalCount: Int!
}

type NicerButSlowerFilmList {
  fid: Int
  title: String
  description: String
  category: String
  price: BigFloat
  length: Int
  rating: MpaaRating
  actors: String
}

"""A `NicerButSlowerFilmList` edge in the connection."""
type NicerButSlowerFilmListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NicerButSlowerFilmList` at the end of the edge."""
  node: NicerButSlowerFilmList
}

"""Methods to use when ordering `NicerButSlowerFilmList`."""
enum NicerButSlowerFilmListsOrderBy {
  NATURAL
  FID_ASC
  FID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PRICE_ASC
  PRICE_DESC
  LENGTH_ASC
  LENGTH_DESC
  RATING_ASC
  RATING_DESC
  ACTORS_ASC
  ACTORS_DESC
}

"""
A condition to be used against `NicerButSlowerFilmList` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input NicerButSlowerFilmListCondition {
  """Checks for equality with the object’s `fid` field."""
  fid: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `price` field."""
  price: BigFloat

  """Checks for equality with the object’s `length` field."""
  length: Int

  """Checks for equality with the object’s `rating` field."""
  rating: MpaaRating

  """Checks for equality with the object’s `actors` field."""
  actors: String
}

"""A connection to a list of `SalesByFilmCategory` values."""
type SalesByFilmCategoriesConnection {
  """A list of `SalesByFilmCategory` objects."""
  nodes: [SalesByFilmCategory]!

  """
  A list of edges which contains the `SalesByFilmCategory` and cursor to aid in pagination.
  """
  edges: [SalesByFilmCategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `SalesByFilmCategory` you could get from the connection.
  """
  totalCount: Int!
}

type SalesByFilmCategory {
  category: String
  totalSales: BigFloat
}

"""A `SalesByFilmCategory` edge in the connection."""
type SalesByFilmCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SalesByFilmCategory` at the end of the edge."""
  node: SalesByFilmCategory
}

"""Methods to use when ordering `SalesByFilmCategory`."""
enum SalesByFilmCategoriesOrderBy {
  NATURAL
  CATEGORY_ASC
  CATEGORY_DESC
  TOTAL_SALES_ASC
  TOTAL_SALES_DESC
}

"""
A condition to be used against `SalesByFilmCategory` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input SalesByFilmCategoryCondition {
  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `totalSales` field."""
  totalSales: BigFloat
}

"""A connection to a list of `SalesByStore` values."""
type SalesByStoresConnection {
  """A list of `SalesByStore` objects."""
  nodes: [SalesByStore]!

  """
  A list of edges which contains the `SalesByStore` and cursor to aid in pagination.
  """
  edges: [SalesByStoresEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SalesByStore` you could get from the connection."""
  totalCount: Int!
}

type SalesByStore {
  store: String
  manager: String
  totalSales: BigFloat
}

"""A `SalesByStore` edge in the connection."""
type SalesByStoresEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SalesByStore` at the end of the edge."""
  node: SalesByStore
}

"""Methods to use when ordering `SalesByStore`."""
enum SalesByStoresOrderBy {
  NATURAL
  STORE_ASC
  STORE_DESC
  MANAGER_ASC
  MANAGER_DESC
  TOTAL_SALES_ASC
  TOTAL_SALES_DESC
}

"""
A condition to be used against `SalesByStore` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SalesByStoreCondition {
  """Checks for equality with the object’s `store` field."""
  store: String

  """Checks for equality with the object’s `manager` field."""
  manager: String

  """Checks for equality with the object’s `totalSales` field."""
  totalSales: BigFloat
}

"""A connection to a list of `StaffList` values."""
type StaffListsConnection {
  """A list of `StaffList` objects."""
  nodes: [StaffList]!

  """
  A list of edges which contains the `StaffList` and cursor to aid in pagination.
  """
  edges: [StaffListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StaffList` you could get from the connection."""
  totalCount: Int!
}

type StaffList {
  id: Int
  name: String
  address: String
  zipCode: String
  phone: String
  city: String
  country: String
  sid: Int
}

"""A `StaffList` edge in the connection."""
type StaffListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StaffList` at the end of the edge."""
  node: StaffList
}

"""Methods to use when ordering `StaffList`."""
enum StaffListsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ZIP_CODE_ASC
  ZIP_CODE_DESC
  PHONE_ASC
  PHONE_DESC
  CITY_ASC
  CITY_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  SID_ASC
  SID_DESC
}

"""
A condition to be used against `StaffList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input StaffListCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `zipCode` field."""
  zipCode: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `sid` field."""
  sid: Int
}

"""A connection to a list of `TodoItem` values."""
type TodoItemsConnection {
  """A list of `TodoItem` objects."""
  nodes: [TodoItem]!

  """
  A list of edges which contains the `TodoItem` and cursor to aid in pagination.
  """
  edges: [TodoItemsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TodoItem` you could get from the connection."""
  totalCount: Int!
}

type TodoItem implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  headline: String!
  body: String
  userId: Int!
  listId: Int

  """Reads a single `TodoList` that is related to this `TodoItem`."""
  todoListByListId: TodoList
}

type TodoList implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  userId: Int!
  name: String!

  """Reads and enables pagination through a set of `TodoItem`."""
  todoItemsByListId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TodoItem`."""
    orderBy: [TodoItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TodoItemCondition
  ): TodoItemsConnection!
}

"""Methods to use when ordering `TodoItem`."""
enum TodoItemsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  HEADLINE_ASC
  HEADLINE_DESC
  BODY_ASC
  BODY_DESC
  USER_ID_ASC
  USER_ID_DESC
  LIST_ID_ASC
  LIST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TodoItem` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TodoItemCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `headline` field."""
  headline: String

  """Checks for equality with the object’s `body` field."""
  body: String

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `listId` field."""
  listId: Int
}

"""A `TodoItem` edge in the connection."""
type TodoItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TodoItem` at the end of the edge."""
  node: TodoItem
}

"""A connection to a list of `TodoList` values."""
type TodoListsConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!

  """
  A list of edges which contains the `TodoList` and cursor to aid in pagination.
  """
  edges: [TodoListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection."""
type TodoListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TodoList` at the end of the edge."""
  node: TodoList
}

"""Methods to use when ordering `TodoList`."""
enum TodoListsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TodoList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TodoListCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  filmInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: FilmInStockInput!
  ): FilmInStockPayload
  filmNotInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: FilmNotInStockInput!
  ): FilmNotInStockPayload
  getCustomerBalance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: GetCustomerBalanceInput!
  ): GetCustomerBalancePayload
  inventoryHeldByCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InventoryHeldByCustomerInput!
  ): InventoryHeldByCustomerPayload
  inventoryInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InventoryInStockInput!
  ): InventoryInStockPayload
  rewardsReport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RewardsReportInput!
  ): RewardsReportPayload
  createTodo(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTodoListRequest!
  ): CreateTodoListResponse
}

"""The output of our `filmInStock` mutation."""
type FilmInStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  pFilmCounts: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `filmInStock` mutation."""
input FilmInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pFilmId: Int
  pStoreId: Int
}

"""The output of our `filmNotInStock` mutation."""
type FilmNotInStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  pFilmCounts: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `filmNotInStock` mutation."""
input FilmNotInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pFilmId: Int
  pStoreId: Int
}

"""The output of our `getCustomerBalance` mutation."""
type GetCustomerBalancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  bigFloat: BigFloat

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `getCustomerBalance` mutation."""
input GetCustomerBalanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pCustomerId: Int
  pEffectiveDate: Datetime
}

"""The output of our `inventoryHeldByCustomer` mutation."""
type InventoryHeldByCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `inventoryHeldByCustomer` mutation."""
input InventoryHeldByCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pInventoryId: Int
}

"""The output of our `inventoryInStock` mutation."""
type InventoryInStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  boolean: Boolean

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `inventoryInStock` mutation."""
input InventoryInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pInventoryId: Int
}

"""The output of our `rewardsReport` mutation."""
type RewardsReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  customers: [Customer]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `rewardsReport` mutation."""
input RewardsReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  minMonthlyPurchases: Int
  minDollarAmountPurchased: BigFloat
}

type CreateTodoListResponse {
  hasError: Boolean!
  fieldErrors: [MutationInputFieldError]!
  todoList: TodoList
  query: Query
}

type MutationInputFieldError {
  path: String!
  message: String!
}

input CreateTodoListRequest {
  listName: String!
  items: [TodoItemRequest]
}

input TodoItemRequest {
  body: String!
  headline: String!
}
